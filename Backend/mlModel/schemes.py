# -*- coding: utf-8 -*-
"""Schemes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cQOuvYDd51SxE_yuvVaLP0YFDnF5y6hf
"""

import pandas as pd
import numpy as np

# --- Load and Clean Data Once ---
df = pd.read_csv("Schemes.csv")

def clean_value(val):
    if pd.isna(val):
        return "Any"
    return str(val).strip().lower()

for col in ['Gender', 'Caste', 'Disability Required', 'Marital Status', 'Religion',
            'State', 'Education Required', 'Minority Status', 'For Orphans', 'Occupation']:
    df[col] = df[col].apply(clean_value)

df['Min Age'] = pd.to_numeric(df['Min Age'], errors='coerce')
df['Max Age'] = pd.to_numeric(df['Max Age'], errors='coerce')
df['Income Max (Annual)'] = pd.to_numeric(df['Income Max (Annual)'], errors='coerce')

# --- Recommendation Function ---
def recommend_schemes(user):
    def is_eligible(row):
        if not pd.isna(row['Min Age']) and user['Age'] < row['Min Age']:
            return False
        if not pd.isna(row['Max Age']) and user['Age'] > row['Max Age']:
            return False
        if row['Gender'] != 'any' and user['Gender'].lower() != row['Gender']:
            return False
        if row['Caste'] != 'any' and row['Caste'] not in user['Caste']:
            return False
        if not pd.isna(row['Income Max (Annual)']) and user['Income'] > row['Income Max (Annual)']:
            return False
        if row['Occupation'] != 'any':
            matched = any(keyword in row['Occupation'] for keyword in user['Occupation'])
            if not matched:
                return False
        for col in ['Disability Required', 'Marital Status', 'Religion', 'State',
                    'Education Required', 'Minority Status', 'For Orphans']:
            if row[col] != 'any' and row[col] != user[col].lower():
                return False
        return True

    eligible_df = df[df.apply(is_eligible, axis=1)]
    return eligible_df[['Scheme Name', 'Description', 'Apply Link']].reset_index(drop=True)

# --- Optional: Format as list of dicts for API ---
def format_response(df, top_k=5):
    return df.head(top_k).to_dict(orient="records")